\documentclass{article}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs} % For better-looking tables

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}

\section{Question 1}

I have used $https://www.w3schools.com/python/$ to look at the build in functions, the arguments and  what it returns. I have used chatgpt, first to get some inspiration to a solutions, tried to simplify it and asked folow up question about the solution. I have used it as well after writing to make the construct of the scentsing more professional. Finally i have used it to make specification to the code and read what it have been written carefully after.



\section{Question 2}


\subsection{What is a data type?}

A data type defines the kind of data a variable can hold and the operations that can be performed on it. 

It could be an string like "Hallo" or an interger "3" or a float "3.2" 

Data types can help with structuring data, make working with data more efficient. For example with optimize memory usage so there is allocated the correct amount of space. It can also help with minimaze "Error Prevention" so that two different types can't combine.



\subsection{Representing colours}

There are multiple methods for representing colors in programming languages. Specifically, in Python, colors can be represented using string names such as "Green", "Yellow", or "Red". Another common approach is to use an RGB (Red-Green-Blue) tuple, where each color component is assigned a value between 0 and 255, indicating its intensity. For example, the color red can be represented as color_rgb = (255, 0, 0).

An alternative method for representing colors is through integer values. In this approach, each entity (e.g., a country in a mapping application) is assigned a numerical color identifier. For instance, country 1 might be assigned color 1, country 2 color 2, and country 3 might reuse color 1.

In my implementation of the color assignment problem in Python, the canExtendColour function operates using integers. However, if the function instead used strings, the expression colouring.get(other) != colour would still be valid, meaning the overall logic would remain unchanged. Similarly, if colors were represented using RGB tuples, the core logic would remain the same.

Each method of color representation has its advantages and disadvantages. Using string names is highly human-readable, which is beneficial for interpretability. However, a predefined list of colors is required (e.g., ["red", "blue", "green", "yellow"]), which can be limiting. The integer representation offers computational efficiency since integer comparisons (e.g., !=) are fast. However, it is less human-readable and requires additional mapping to integrate with libraries such as Matplotlib. The RGB representation provides high flexibility and seamless integration with many external libraries. Additionally, it allows for dynamic color generation and customization. However, it is less human-readable compared to string-based representations.

For my implementation, I chose to use integers, as the number of required colors is relatively small, making this approach both efficient and sufficient for the problem at hand.

\subsection{Representing Neighbour Relation}

See the contry type in the next section, in the code.


\subsection{Colouring problem}



\lstinputlisting[language=Octave]{scr/colouring.py}



\section{ Question 3}

\subsection{}


\lstinputlisting[language=Octave]{scr/diku.py}


\subsection{}

For this solution i used imperative programming witch is simple and easy for small programs that is not going to be reused over and over agian. Imperative programming makes it easy to manipulate variables, memory, and data structures directly. The drawback with imperative programming is also that there can easy be errors due to small modifications in the code , with unintended side effects. 

For complex problems, it can be hard to maintain, and the lack of modularity makes it hard to reuse it. And therefore wouldn't it be a optimal choice with that setting then funtional programming or obejct orinted programming would be more sutable.



\subsection{}

I used input partition, because of different benefits,as we learned in the lectures from Friz, that "testing is NOT illustrating that your program runs on a friendly case" it is suppose to find where the code breaks. By covering different types of inputs (valid and invalid), it increases the chances of discovering boundary issues, edge cases, and unexpected behavior in the code. At the same time it makes for efficient testing, instead of testing all possible inputs, which can be impractical, input partitioning reduces the number of test cases while still covering important scenarios. And it ensuring key input conditions are checked without random guessing so a systematic and Structured Approach to testing. 

I will try to test if it finds all the "DIKU" in a sample test, i have made one with only 2 and if it counts correctly it will print out test1 passed. Then i do another test for a different word than what is in the sample. Then i test for a single character, and then i test for an empty grid.


\section{Question 4}

\subsection{}


\lstinputlisting[language=Octave]{scr/cards.py}

\subsection{}

This problem is like the previously problem an small one so i used imperative programming again here with the same benefit as i describe before. 



\subsection{}
 I use input partition the same as in the previous program with the same benefits. 

First I test the $parse_card()$ function, it is supposed to separate from a string, the winning numbers and owned numbers. First i try with some valid test cases, with only one winner and one owned number. After that i try some invalid test cases with wrong format like without $|$, or with multiple of $|$.

I make a function $test_points()$ that test if we get what we expect from the $calculate_points$ function. First where we expect 0 return, then where we expect 2 and finally last where we expect 0 return since there is no numbers we have.

the i test if the loading of the cards works, using the $load_cards()$ function. First by creating a temporary file called $test_file.txt$ with 2 cards in it, and then using the function to load it. and giving the expected output.

And then finally  i test if the calculation of total points works with the function $calculate_total_points()$ with an sample cards and an empty cards after and double checking if i got the expected result.

\subsection{}

In my programs i used variables often, and often also where it is mutable in loops for example where it is used to count to

\section*{Variable Descriptions}
\begin{table}[h]
    \centering
    \begin{tabular}{p{4cm} p{4cm} p{7cm}} % Adjusted column widths
        \toprule
        \textbf{Variable Name} & \textbf{Function} & \textbf{Description} \\
        \midrule
        $card\_data$ & parse\_card & String containing winning and owned numbers separated by "\texttt{|}" \\
        $parts$ & parse\_card & List created by splitting $card\_data$ on "\texttt{|}" \\
        $winning\_numbers$ & parse\_card & Set of numbers from the first part (winning numbers) \\
        $owned\_numbers$ & parse\_card & Set of numbers from the second part (owned numbers) \\
        $winning\_numbers$ & calculate\_points & Set of winning numbers from $parse\_card(card\_data)$ \\
        $owned\_numbers$ & calculate\_points & Set of owned numbers from $parse\_card(card\_data)$ \\
        $matched\_numbers$ & calculate\_points & Set of numbers that appear in both $winning\_numbers$ and $owned\_numbers$ \\
        $points$ & calculate\_points & Integer tracking total points, doubling for each match \\
        $filename$ & load\_cards & String representing the file path for card data \\
        $file$ & load\_cards & File object used to read from $filename$ \\
        $line$ & load\_cards & A single line from the file, formatted as "CardX: winning\_numbers | owned\_numbers" \\
        $cards$ & calculate\_total\_points & List of strings containing "winning\_numbers | owned\_numbers" \\
        $total\_points$ & calculate\_total\_points & Integer storing the total sum of points from all cards \\
        $card$ & calculate\_total\_points & Single string representing a card from the $cards$ list \\
        $cards$ & Main Program & List of parsed card data from "\texttt{../Data/cards.txt}" \\
        $total\_points$ & Main Program & Integer representing the total sum of points from all cards \\
        \bottomrule
    \end{tabular}
    \caption{Variable Descriptions in the Card Points Program}
    \label{tab:variables}
\end{table}


\end{document}